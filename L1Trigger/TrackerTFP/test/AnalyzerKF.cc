#include "FWCore/Framework/interface/one/EDAnalyzer.h"
#include "FWCore/Framework/interface/Run.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/Utilities/interface/EDGetToken.h"
#include "FWCore/Utilities/interface/InputTag.h"
#include "FWCore/Utilities/interface/Exception.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "DataFormats/Common/interface/Handle.h"

#include "SimTracker/TrackTriggerAssociation/interface/StubAssociation.h"
#include "L1Trigger/TrackerDTC/interface/Setup.h"
#include "L1Trigger/TrackerTFP/interface/DataFormats.h"
#include "L1Trigger/TrackerTFP/interface/LayerEncoding.h"
#include "L1Trigger/TrackerTFP/interface/KalmanFilterFormats.h"

#include <TProfile.h>
#include <TH1F.h>
#include <TEfficiency.h>

#include <vector>
#include <deque>
#include <set>
#include <cmath>
#include <numeric>
#include <sstream>

using namespace std;
using namespace edm;
using namespace trackerDTC;
using namespace tt;

namespace trackerTFP {

  /*! \class  trackerTFP::AnalyzerKF
   *  \brief  Class to analyze hardware like structured TTTrack Collection generated by Kalman Filter
   *  \author Thomas Schuh
   *  \date   2020, Sep
   */
  class AnalyzerKF : public one::EDAnalyzer<one::WatchRuns, one::SharedResources> {
  public:
    AnalyzerKF(const ParameterSet& iConfig);
    void beginJob() override {}
    void beginRun(const Run& iEvent, const EventSetup& iSetup) override;
    void analyze(const Event& iEvent, const EventSetup& iSetup) override;
    void endRun(const Run& iEvent, const EventSetup& iSetup) override {}
    void endJob() override;

  private:
    //
    void associate(const TTTracks& ttTracks, const StubAssociation* ass, set<TPPtr>& tps, int& sum, const vector<TH1F*>& his, TProfile* prof) const;

    // ED input token of accepted TTTracks
    EDGetTokenT<StreamsTrack> edGetTokenAccepted_;
    // ED input token of lost TTTracks
    EDGetTokenT<StreamsTrack> edGetTokenLost_;
    // ED input token of TTStubRef to selected TPPtr association
    EDGetTokenT<StubAssociation> edGetTokenSelection_;
    // ED input token of TTStubRef to recontructable TPPtr association
    EDGetTokenT<StubAssociation> edGetTokenReconstructable_;
    // Setup token
    ESGetToken<Setup, SetupRcd> esGetTokenSetup_;
    // DataFormats token
    ESGetToken<DataFormats, DataFormatsRcd> esGetTokenDataFormats_;
    // LayerEncoding token
    ESGetToken<LayerEncoding, LayerEncodingRcd> esGetTokenLayerEncoding_;
    // stores, calculates and provides run-time constants
    const Setup* setup_;
    //
    const DataFormats* dataFormats_;
    //
    const LayerEncoding* layerEncoding_;
    // enables analyze of TPs
    bool useMCTruth_;
    //
    int nEvents_;

    // Histograms

    TProfile* prof_;
    TProfile* profChannel_;
    TH1F* hisChannel_;
    vector<TH1F*> hisRes_;
    TProfile* profResZ0_;
    TH1F* hisEffEta_;
    TH1F* hisEffEtaTotal_;
    TEfficiency* effEta_;
    TH1F* hisEffQoverPt_;
    TH1F* hisEffQoverPtTotal_;
    TEfficiency* effQoverPt_;

    // printout
    stringstream log_;
  };

  AnalyzerKF::AnalyzerKF(const ParameterSet& iConfig) :
    useMCTruth_(iConfig.getParameter<bool>("UseMCTruth")),
    nEvents_(0),
    hisRes_(4)
  {
    usesResource("TFileService");
    // book in- and output ED products
    const string& label = iConfig.getParameter<string>("LabelKF");
    const string& branchAccepted = iConfig.getParameter<string>("BranchAccepted");
    const string& branchLost = iConfig.getParameter<string>("BranchLost");
    edGetTokenAccepted_ = consumes<StreamsTrack>(InputTag(label, branchAccepted));
    edGetTokenLost_ = consumes<StreamsTrack>(InputTag(label, branchLost));
    if (useMCTruth_) {
      const auto& inputTagSelecttion = iConfig.getParameter<InputTag>("InputTagSelection");
      const auto& inputTagReconstructable = iConfig.getParameter<InputTag>("InputTagReconstructable");
      edGetTokenSelection_ = consumes<StubAssociation>(inputTagSelecttion);
      edGetTokenReconstructable_ = consumes<StubAssociation>(inputTagReconstructable);
    }
    // book ES products
    esGetTokenSetup_ = esConsumes<Setup, SetupRcd, Transition::BeginRun>();
    esGetTokenDataFormats_ = esConsumes<DataFormats, DataFormatsRcd, Transition::BeginRun>();
    esGetTokenLayerEncoding_ = esConsumes<LayerEncoding, LayerEncodingRcd, Transition::BeginRun>();
    // initial ES products
    setup_ = nullptr;
    dataFormats_ = nullptr;
    layerEncoding_ = nullptr;
    // log config
    log_.setf(ios::fixed, ios::floatfield);
    log_.precision(4);
  }

  void AnalyzerKF::beginRun(const Run& iEvent, const EventSetup& iSetup) {
    // helper class to store configurations
    setup_ = &iSetup.getData(esGetTokenSetup_);
    dataFormats_ = &iSetup.getData(esGetTokenDataFormats_);
    layerEncoding_ = &iSetup.getData(esGetTokenLayerEncoding_);
    // book histograms
    Service<TFileService> fs;
    TFileDirectory dir;
    dir = fs->mkdir("KF");
    prof_ = dir.make<TProfile>("Counts", ";", 9, 0.5, 9.5);
    prof_->GetXaxis()->SetBinLabel(1, "Stubs");
    prof_->GetXaxis()->SetBinLabel(2, "Tracks");
    prof_->GetXaxis()->SetBinLabel(3, "Lost Tracks");
    prof_->GetXaxis()->SetBinLabel(4, "Matched Tracks");
    prof_->GetXaxis()->SetBinLabel(5, "All Tracks");
    prof_->GetXaxis()->SetBinLabel(6, "Found TPs");
    prof_->GetXaxis()->SetBinLabel(7, "Found selected TPs");
    prof_->GetXaxis()->SetBinLabel(8, "Lost TPs");
    prof_->GetXaxis()->SetBinLabel(9, "All TPs");
    // channel occupancy
    constexpr int maxOcc = 180;
    const int numChannels = setup_->numRegions();
    hisChannel_ = dir.make<TH1F>("His Channel Occupancy", ";", maxOcc, -.5, maxOcc - .5);
    profChannel_ = dir.make<TProfile>("Prof Channel Occupancy", ";", numChannels, -.5, numChannels - .5);
    // resoultions
    static const vector<string> names = {"phiT", "qOverPt", "zT", "cot"};
    static const vector<double> ranges = {.01, .1, 5, .1};
    for (int i = 0; i < 4; i++) {
      const double range = ranges[i];
      hisRes_[i] = dir.make<TH1F>(("HisRes" + names[i]).c_str(), ";", 100, -range, range);
    }
    profResZ0_ = dir.make<TProfile>("ProfResZ0", ";", 128, -2.5, 2.5);
    // Efficiencies
    hisEffEtaTotal_ = dir.make<TH1F>("HisTPEtaTotal", ";", 128, -2.5, 2.5);
    hisEffEta_ = dir.make<TH1F>("HisTPEta", ";", 128, -2.5, 2.5);
    effEta_ = dir.make<TEfficiency>("EffEta", ";", 128, -2.5, 2.5);
    const double rangeQoverPt = dataFormats_->format(Variable::qOverPt, Process::dr).range();
    hisEffQoverPt_ = dir.make<TH1F>("HisTPQoverPt", ";", 32, -rangeQoverPt / 2., rangeQoverPt / 2.);
    hisEffQoverPtTotal_ = dir.make<TH1F>("HisTPQoverPtTotal", ";", 32, -rangeQoverPt / 2., rangeQoverPt / 2.);
    effQoverPt_ = dir.make<TEfficiency>("EffQoverPt", ";", 32, -rangeQoverPt / 2., rangeQoverPt / 2.);
  }

  void AnalyzerKF::analyze(const Event& iEvent, const EventSetup& iSetup) {
    auto fill = [this](const TPPtr& tpPtr, TH1F* hisEta, TH1F* hisQoverPt) {
      hisEta->Fill(tpPtr->eta());
      hisQoverPt->Fill(tpPtr->charge() / tpPtr->pt() * setup_->invPtToDphi());
      //if (abs(tpPtr->eta()) < 1. && tpPtr->pt() < 4.)
        //throw cms::Exception("...");
    };
    // read in kf products
    Handle<StreamsTrack> handleAccepted;
    iEvent.getByToken<StreamsTrack>(edGetTokenAccepted_, handleAccepted);
    Handle<StreamsTrack> handleLost;
    iEvent.getByToken<StreamsTrack>(edGetTokenLost_, handleLost);
    // read in MCTruth
    const StubAssociation* selection = nullptr;
    const StubAssociation* reconstructable = nullptr;
    if (useMCTruth_) {
      Handle<StubAssociation> handleSelection;
      iEvent.getByToken<StubAssociation>(edGetTokenSelection_, handleSelection);
      selection = handleSelection.product();
      prof_->Fill(9, selection->numTPs());
      Handle<StubAssociation> handleReconstructable;
      iEvent.getByToken<StubAssociation>(edGetTokenReconstructable_, handleReconstructable);
      reconstructable = handleReconstructable.product();
      for (const auto& p : selection->getTrackingParticleToTTStubsMap())
        fill(p.first, hisEffEtaTotal_, hisEffQoverPtTotal_);
    }
    // analyze kf products and associate found tracks with reconstrucable TrackingParticles
    set<TPPtr> tpPtrs;
    set<TPPtr> tpPtrsSelection;
    set<TPPtr> tpPtrsLost;
    int allMatched(0);
    int allTracks(0);
    auto toTTTrack = [this](const FrameTrack& frame) {
      TrackKF track(frame, dataFormats_);
      layerEncoding_->addTTStubRefs(track);
      TTTrack ttTrack = track.ttTrack();
      ttTrack.setStubPtConsistency(frame.first->hitPattern());
      return ttTrack;
    };
    for (int region = 0; region < setup_->numRegions(); region++) {
      const StreamTrack& accepted = handleAccepted->at(region);
      const StreamTrack& lost = handleLost->at(region);
      hisChannel_->Fill(accepted.size());
      profChannel_->Fill(region, accepted.size());
      TTTracks tracks;
      const int nTracks = accumulate(accepted.begin(), accepted.end(), 0, [](int& sum, const FrameTrack& frame){ return sum += frame.first.isNonnull() ? 1 : 0; });
      tracks.reserve(nTracks);
      transform(accepted.begin(), accepted.end(), back_inserter(tracks), toTTTrack);
      TTTracks tracksLost;
      const int nLost = accumulate(lost.begin(), lost.end(), 0, [](int& sum, const FrameTrack& frame){ return sum += frame.first.isNonnull() ? 1 : 0; });
      tracksLost.reserve(nLost);
      transform(lost.begin(), lost.end(), back_inserter(tracksLost), toTTTrack);
      allTracks += nTracks;
      if (!useMCTruth_)
        continue;
      int tmp(0);
      associate(tracks, selection, tpPtrsSelection, tmp, hisRes_, profResZ0_);
      associate(tracksLost, selection, tpPtrsLost, tmp, vector<TH1F*>(), nullptr);
      associate(tracks, reconstructable, tpPtrs, allMatched, vector<TH1F*>(), nullptr);
      prof_->Fill(2, nTracks);
      prof_->Fill(3, nLost);
    }
    for (const TPPtr& tpPtr : tpPtrsSelection)
      fill(tpPtr, hisEffEta_, hisEffQoverPt_);
    vector<TPPtr> recovered;
    recovered.reserve(tpPtrsLost.size());
    set_intersection(tpPtrsLost.begin(), tpPtrsLost.end(), tpPtrs.begin(), tpPtrs.end(), back_inserter(recovered));
    for(const TPPtr& tpPtr : recovered)
      tpPtrsLost.erase(tpPtr);
    prof_->Fill(4, allMatched);
    prof_->Fill(5, allTracks);
    prof_->Fill(6, tpPtrs.size());
    prof_->Fill(7, tpPtrsSelection.size());
    prof_->Fill(8, tpPtrsLost.size());
    nEvents_++;
  }

  void AnalyzerKF::endJob() {
    // effi
    effEta_->SetPassedHistogram(*hisEffEta_, "f");
    effEta_->SetTotalHistogram (*hisEffEtaTotal_, "f");
    effQoverPt_->SetPassedHistogram(*hisEffQoverPt_, "f");
    effQoverPt_->SetTotalHistogram (*hisEffQoverPtTotal_, "f");
    // printout SF summary
    const double totalTPs = prof_->GetBinContent(9);
    const double numStubs = prof_->GetBinContent(1);
    const double numTracks = prof_->GetBinContent(2);
    const double numTracksLost = prof_->GetBinContent(3);
    const double totalTracks = prof_->GetBinContent(5);
    const double numTracksMatched = prof_->GetBinContent(4);
    const double numTPsAll = prof_->GetBinContent(6);
    const double numTPsEff = prof_->GetBinContent(7);
    const double numTPsLost = prof_->GetBinContent(8);
    const double errStubs = prof_->GetBinError(1);
    const double errTracks = prof_->GetBinError(2);
    const double errTracksLost = prof_->GetBinError(3);
    const double fracFake = (totalTracks - numTracksMatched) / totalTracks;
    const double fracDup = (numTracksMatched - numTPsAll) / totalTracks;
    const double eff = numTPsEff / totalTPs;
    const double errEff = sqrt(eff * (1. - eff) / totalTPs / nEvents_);
    const double effLoss = numTPsLost / totalTPs;
    const double errEffLoss = sqrt(effLoss * (1. - effLoss) / totalTPs / nEvents_);
    const vector<double> nums = {numStubs, numTracks, numTracksLost};
    const vector<double> errs = {errStubs, errTracks, errTracksLost};
    const int wNums = ceil(log10(*max_element(nums.begin(), nums.end()))) + 5;
    const int wErrs = ceil(log10(*max_element(errs.begin(), errs.end()))) + 5;
    log_ << "                         KF  SUMMARY                         " << endl;
    //log_ << "number of stubs       per TFP = " << setw(wNums) << numStubs << " +- " << setw(wErrs) << errStubs << endl;
    log_ << "number of tracks      per TFP = " << setw(wNums) << numTracks << " +- " << setw(wErrs) << errTracks << endl;
    log_ << "number of lost tracks per TFP = " << setw(wNums) << numTracksLost << " +- " << setw(wErrs) << errTracksLost << endl;
    log_ << "          tracking efficiency = " << setw(wNums) << eff << " +- " << setw(wErrs) << errEff << endl;
    log_ << "     lost tracking efficiency = " << setw(wNums) << effLoss << " +- " << setw(wErrs) << errEffLoss << endl;
    log_ << "                    fake rate = " << setw(wNums) << fracFake << endl;
    log_ << "               duplicate rate = " << setw(wNums) << fracDup << endl;
    log_ << "=============================================================";
    LogPrint("L1Trigger/TrackerTFP") << log_.str();
  }

  //
  void AnalyzerKF::associate(const TTTracks& ttTracks, const StubAssociation* ass, set<TPPtr>& tps, int& sum, const vector<TH1F*>& his, TProfile* prof) const {
    for (const TTTrack<Ref_Phase2TrackerDigi_>& ttTrack : ttTracks) {
      const vector<TTStubRef>& ttStubRefs = ttTrack.getStubRefs();
      const vector<TPPtr>& tpPtrs = ass->associate(ttStubRefs);
      if (tpPtrs.empty())
        continue;
      sum++;
      copy(tpPtrs.begin(), tpPtrs.end(), inserter(tps, tps.begin()));
      if (his.empty())
        continue;
      for (const TPPtr& tpPtr : tpPtrs) {
        const double phi0 = tpPtr->phi();
        const double cot = sinh(tpPtr->eta());
        const double qOverPt = tpPtr->charge() / tpPtr->pt();
        const math::XYZPointD& v = tpPtr->vertex();
        const double z0 = v.z() - cot * (v.x() * cos(phi0) + v.y() * sin(phi0));
        const double dCot = cot - ttTrack.tanL();
        const double dZ0 = z0 - ttTrack.z0();
        const double dQoverPt = qOverPt - ttTrack.rInv();
        const double dPhi0 = deltaPhi(phi0 - ttTrack.phi());
        const vector<double> ds = {dPhi0, dQoverPt, dZ0, dCot};
        for (int i = 0; i < (int)ds.size(); i++)
          his[i]->Fill(ds[i]);
        prof->Fill(tpPtr->eta(), abs(dZ0));
        if (abs(dZ0) > 2.) {
          cout << "TP" << endl;
          for (const TTStubRef& ttStubRef : ass->findTTStubRefs(tpPtr)) {
            const GlobalPoint& gp = setup_->stubPos(ttStubRef);
            cout << gp.perp() << " " << gp.phi() << " " << gp.z() << " " << setup_->layerId(ttStubRef) << " " << setup_->dPhi(ttStubRef) / 2. << " " << setup_->dZ(ttStubRef) / 2. << endl;
          }
          cout << "Fitted" << endl;
          for (const TTStubRef& ttStubRef : ttStubRefs) {
            const GlobalPoint& gp = setup_->stubPos(ttStubRef);
            cout << gp.perp() << " " << gp.phi() << " " << gp.z() << " " << setup_->layerId(ttStubRef) << " " << setup_->dPhi(ttStubRef) / 2. << " " << setup_->dZ(ttStubRef) / 2. << endl;
          }
          cout << "m0KF = " << " " << -ttTrack.rInv() * setup_->invPtToDphi() << endl;
          cout << "c0KF = " << " " << ttTrack.phi() << endl;
          cout << "m1KF = " << " " << ttTrack.tanL() << endl;
          cout << "c1KF = " << " " << ttTrack.z0() << endl;
          cout << "m0TP = " << " " << -tpPtr->charge() / tpPtr->pt() * setup_->invPtToDphi() << endl;
          cout << "c0TP = " << " " << tpPtr->phi() << endl;
          cout << "m1TP = " << " " << sinh(tpPtr->eta()) << endl;
          const math::XYZPointD& v = tpPtr->vertex();
          cout << "c1TP = " << " " << v.z() - sinh(tpPtr->eta()) * (v.x() * cos(tpPtr->phi()) + v.y() * sin(tpPtr->phi())) << endl;
          cout << ttTrack.phiSector() << " " << ttTrack.stubPtConsistency();
          throw cms::Exception("...");
        }
      }
    }
  }

}  // namespace trackerTFP

DEFINE_FWK_MODULE(trackerTFP::AnalyzerKF);